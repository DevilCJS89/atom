#!/usr/bin/env python3
"""
Runs several calibration executions in batch_execution
"""
import argparse
import os
import subprocess
import yaml
import jinja2

from colorama import Fore, Back, Style
from pytictoc import TicToc

from atom_core.config_io import resolvePath

# ----------------------------------------------------------------------------------------------------------------------
# Define here the list of commands you want to execute in batch_execution
# TODO we could have a yaml or a json defining the commands to be batched...
# dataset_path = resolvePath('~/datasets/mmtbot/train_dataset/')
# output_folder = resolvePath(dataset_path + '/results')
#
# cmd_prefix = 'rosrun atom_calibration calibrate -json ' + dataset_path + '/data_collected.json'
#
# batches = [
#     {'name': 'nig0.01_0.020',
#      'command': cmd_prefix + " -csf 'lambda name: int(name)<1' -nig 0.01 0.020 -ss 1",
#      'files_to_collect': [dataset_path + '/atom_calibration.json', '/tmp/optimized.urdf.xacro']},
#     {'name': 'nig0.03_0.020',
#      'command': cmd_prefix + " -csf 'lambda name: int(name)<1'  -nig 0.03 0.020 -ss 1",
#      'files_to_collect': [dataset_path + '/atom_calibration.json', '/tmp/optimized.urdf.xacro']}
# ]


# ----------------------------------------------------------------------------------------------------------------------

def main():
    ap = argparse.ArgumentParser()  # Parse command line arguments
    ap.add_argument("-v", "--verbose", help="Prints the output of each command to the terminal.", action='store_true',
                    default=False)
    ap.add_argument("-f", "--filename", help="Yml file containing a description of all the commands to run in batch.",
                    required=True, type=str)

    args = vars(ap.parse_args())

    # Load and render config file
    with open(args['filename']) as f:
        dataMap = yaml.safe_load(f)

    env = jinja2.Environment(loader=jinja2.FileSystemLoader(searchpath='.'))
    template = env.get_template(args['filename'])
    config = yaml.safe_load(template.render(**dataMap))
    print(Fore.BLUE + Back.YELLOW + 'Loaded config file ' + args['filename'] + Style.RESET_ALL)
    if args['verbose']:
        print(config)

    tictoc = TicToc()

    if not os.path.exists(config['output_folder']):  # create output folder if it does not exist.
        print(Fore.BLUE + Back.YELLOW + 'Creating output folder at: ' + config['output_folder'] + Style.RESET_ALL)
        os.mkdir(config['output_folder'])  # Create the new folder

    for idx, batch in enumerate(config['batches']):  # cyce through commands in batch_execution.
        print('\n\n' + Style.BRIGHT + Fore.BLUE + Back.YELLOW + 'Batch' + str(idx) + ', executing command:' +
              Style.RESET_ALL + '\n' + Fore.BLUE + Back.YELLOW + batch['cmd'] + Style.RESET_ALL)

        # Start executing command.
        tictoc.tic()
        proc = subprocess.Popen(batch['cmd'], shell=True, universal_newlines=True, stdout=subprocess.PIPE,
                                stderr=subprocess.PIPE)
        proc.wait()  # wait for command to finish
        toc = str(round(tictoc.tocvalue(), 5))

        if not proc.returncode == 0:  # Check output of command.
            print(Fore.RED + Back.YELLOW + 'Error running command. stderr is:' + Style.RESET_ALL)
            print(proc.stderr.read())
            exit(0)

        output = proc.stdout.read()  # save sdtout to file
        if args['verbose']:
            print(Fore.BLUE + Back.YELLOW + 'Batch' + str(idx) + ' terminated, stdout is:' + Style.RESET_ALL)
            print(output)

        prefix = str(idx).zfill(2) + '_'
        filename = config['output_folder'] + '/' + prefix + batch['name'] + '_stdout.txt'
        with open(filename, 'w') as f:
            f.write(output)

        # Collect output files
        for file in batch['files_to_collect']:
            if not os.path.exists(file):
                raise ValueError('File ' + file + ' should be collected but does not exist.')

            filename_out = config['output_folder'] + '/' + prefix + batch['name'] + '_' + os.path.basename(file)
            print(Fore.BLUE + Back.YELLOW + 'Moving file ' + file + ' to ' + filename_out + Style.RESET_ALL)
            p = subprocess.Popen('cp ' + file + ' ' + filename_out, shell=True, universal_newlines=True,
                                 stdout=subprocess.PIPE, stderr=subprocess.PIPE).wait()

        print(Fore.BLUE + Back.YELLOW + 'Command executed in ' + toc + ' secs.' + Style.RESET_ALL)


if __name__ == "__main__":
    main()
