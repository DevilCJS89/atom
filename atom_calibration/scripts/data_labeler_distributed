#!/usr/bin/env python3

# stdlib
import argparse
import os

import atom_core.config_io
import atom_core.ros_utils
from atom_core.config_io import execute, loadConfig
import sys

# 3rd-party
import ros
import rospy
from tf.listener import TransformListener

from interactive_markers.interactive_marker_server import InteractiveMarkerServer
from interactive_markers.menu_handler import MenuHandler
from visualization_msgs.msg import InteractiveMarkerControl, Marker, InteractiveMarker
from colorama import Style, Fore

# local packages
from atom_calibration.collect_distributed.class_data_labeler import ClassDataLabeler
from atom_core.naming import generateKey

server = None
menu_handler = MenuHandler()


def menuFeedback(feedback):
    handle = feedback.menu_entry_id
    if handle == 1:  # collect snapshot
        print('Save collection selected')
        data_collector.saveCollection()


def initMenu():
    menu_handler.insert("Save collection", callback=menuFeedback)


def createInteractiveMarker(world_link):
    marker = InteractiveMarker()
    marker.header.frame_id = world_link
    trans = (1, 0, 1)
    marker.pose.position.x = trans[0]
    marker.pose.position.y = trans[1]
    marker.pose.position.z = trans[2]
    quat = (0, 0, 0, 1)
    marker.pose.orientation.x = quat[0]
    marker.pose.orientation.y = quat[1]
    marker.pose.orientation.z = quat[2]
    marker.pose.orientation.w = quat[3]
    marker.scale = 0.2

    marker.name = 'menu'
    marker.description = 'menu'

    # insert a box
    control = InteractiveMarkerControl()
    control.always_visible = True

    marker_box = Marker()
    marker_box.type = Marker.SPHERE
    marker_box.scale.x = marker.scale * 0.7
    marker_box.scale.y = marker.scale * 0.7
    marker_box.scale.z = marker.scale * 0.7
    marker_box.color.r = 0
    marker_box.color.g = 1
    marker_box.color.b = 0
    marker_box.color.a = 0.2

    control.markers.append(marker_box)
    marker.controls.append(control)

    marker.controls[0].interaction_mode = InteractiveMarkerControl.MOVE_3D

    control = InteractiveMarkerControl()
    control.orientation.w = 1
    control.orientation.x = 1
    control.orientation.y = 0
    control.orientation.z = 0
    control.name = "move_x"
    control.interaction_mode = InteractiveMarkerControl.MOVE_AXIS
    control.orientation_mode = InteractiveMarkerControl.FIXED
    marker.controls.append(control)

    control = InteractiveMarkerControl()
    control.orientation.w = 1
    control.orientation.x = 0
    control.orientation.y = 1
    control.orientation.z = 0
    control.name = "move_z"
    control.interaction_mode = InteractiveMarkerControl.MOVE_AXIS
    control.orientation_mode = InteractiveMarkerControl.FIXED
    marker.controls.append(control)

    control = InteractiveMarkerControl()
    control.orientation.w = 1
    control.orientation.x = 0
    control.orientation.y = 0
    control.orientation.z = 1
    control.name = "move_y"
    control.interaction_mode = InteractiveMarkerControl.MOVE_AXIS
    control.orientation_mode = InteractiveMarkerControl.FIXED
    marker.controls.append(control)

    server.insert(marker, markerFeedback)
    menu_handler.apply(server, marker.name)


def markerFeedback(feedback):
    print('Received feedback')


if __name__ == "__main__":
    # Parse command line arguments
    ap = argparse.ArgumentParser()
    ap.add_argument("-s", "--marker_size", help='Scale of the interactive markers.', type=float, default=0.5)
    ap.add_argument("-c", "--calibration_file", help='full path to calibration file.', type=str, required=True)
    ap.add_argument("-sn", "--sensor_name", help='Name of sensor to label.', type=str, required=True)
    ap.add_argument("-ov", "--overwrite", help="Overwrite dataset folder if it exists.", action='store_true',
                    default=False)
    ap.add_argument("-ssl", "--skip_sensor_labelling", default=None, type=lambda s: eval(s, globals()),
                    help='A string to be evaluated into a lambda function that receives a sensor name as input and '
                         'returns True or False to indicate if the sensor should be labelled.'
                         ' The Syntax is lambda name: f(x), where f(x) is the function in python '
                         'language. Example: lambda name: name in ["lidar1", "camera2"] , to avoid labelling of sensors'
                         ' lida1 and camera2.')

    args = vars(ap.parse_args(args=atom_core.ros_utils.filterLaunchArguments(sys.argv)))
    print("\nArgument list=" + str(args) + '\n')

    # Initialize ROS stuff
    rospy.init_node("data_labeller_distributed")

    listener = TransformListener()
    # rospack = rospkg.RosPack()  # get an instance of RosPack with the default search paths

    # server = InteractiveMarkerServer("data_labeler")
    robot_description = rospy.get_param('/robot_description')
    # rospy.sleep(0.5)


    config = loadConfig(args['calibration_file'])
    if config is None:
        sys.exit(1)  # loadJSON should tell you why.


    world_link = config['world_link']

    # Create a dictionary that describes this sensor
    value = config['sensors'][args['sensor_name']]
    sensor_dict = {'_name': args['sensor_name'], 'modality': value['modality'], 'parent': value['link'],
                  'calibration_parent': value['parent_link'],
                  'calibration_child': value['child_link']}

    # TODO replace by utils function
    print("Waiting for message " + value['topic_name'] + ' ...')
    msg = rospy.wait_for_message(value['topic_name'], rospy.AnyMsg)
    print('... received!')
    connection_header = msg._connection_header['type'].split('/')
    ros_pkg = connection_header[0] + '.msg'
    msg_type = connection_header[1]
    print('Topic ' + value['topic_name'] + ' has type ' + msg_type)
    sensor_dict['topic'] = value['topic_name']
    sensor_dict['msg_type'] = msg_type
    modality = value['modality']

    # If topic contains a message type then get a camera_info message to store along with the sensor data
    if modality == 'rgb' or modality == 'depth':  # if it is an image must get camera_info
        sensor_dict['camera_info_topic'] = os.path.dirname(sensor_dict['topic']) + '/camera_info'
        from sensor_msgs.msg import CameraInfo

        print('Waiting for camera_info message on topic ' + sensor_dict['camera_info_topic'] + ' ...')
        camera_info_msg = rospy.wait_for_message(sensor_dict['camera_info_topic'], CameraInfo)
        print('... received!')
        from rospy_message_converter import message_converter

        sensor_dict['camera_info'] = message_converter.convert_ros_message_to_dictionary(camera_info_msg)
        # sensor_dict['camera_info_msg'] = camera_info_msg
        # print(camera_info_msg)

    # Get the kinematic chain form world_link to this sensor's parent link
    now = rospy.Time()
    print('Waiting for transformation from ' + value['link'] + ' to ' + world_link)
    listener.waitForTransform(value['link'], world_link, now, rospy.Duration(5))
    print('... received!')
    chain = listener.chain(value['link'], now, world_link, now, world_link)

    chain_list = []
    for parent, child in zip(chain[0::], chain[1::]):
        key = generateKey(parent, child)
        chain_list.append({'key': key, 'parent': parent, 'child': child})

    sensor_dict['chain'] = chain_list  # Add to sensor dictionary

    sensor_labeler = ClassDataLabeler(sensor_dict,
                                      args['marker_size'], config['calibration_pattern'],
                                      label_data=True)
    # Process robot description and create an instance of class Sensor for each sensor
    # data_collector = DataCollectorAndLabeler(args, server, menu_handler)

    rospy.spin()

