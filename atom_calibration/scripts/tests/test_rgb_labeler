#!/usr/bin/env python3

import os
import sys
import argparse

import cv2
import numpy as np
import atom_core.config_io
import rospy
import tf
from sensor_msgs.msg import Image, CameraInfo
from cv_bridge import CvBridge
from atom_calibration.collect import patterns
from atom_core.geometry import traslationRodriguesToTransform
from tf import transformations


class SimplePatternDetector:

    def __init__(self, args, config):

        size = {'x': config['calibration_pattern']['dimension']['x'],
                'y': config['calibration_pattern']['dimension']['y']}
        length = config['calibration_pattern']['size']
        inner_length = config['calibration_pattern']['inner_size']
        dictionary = config['calibration_pattern']['dictionary']
        self.args = args
        self.config = config

        if config['calibration_pattern']['pattern_type'] == 'charuco':
            self.pattern = patterns.CharucoPattern(size, length, inner_length, dictionary)
        elif config['calibration_pattern']['pattern_type'] == 'chessboard':
            self.pattern = patterns.ChessboardPattern(size, length)
        else:
            rospy.logerr("Unknown pattern '{}'".format(config['calibration_pattern']['pattern_type']))
            sys.exit(1)

        # Get a camera_info message
        topic = config['sensors'][args['sensor_name']]['topic_name']
        camera_info_topic = os.path.dirname(topic) + '/camera_info'

        if camera_info_topic is not None:
            print('Waiting for camera_info message on topic ' + camera_info_topic + ' ...')
            self.camera_info_msg = rospy.wait_for_message(camera_info_topic, CameraInfo)
            print('... received!')
            self.broadcaster = tf.TransformBroadcaster()
        else:
            self.camera_info_msg = None
            self.broadcaster = None

        self.sub = rospy.Subscriber(topic, Image, self.onImageReceived, queue_size=1)
        self.bridge = CvBridge()
        self.image_pub = rospy.Publisher(topic + '/labeled', Image, queue_size=1)

    def onImageReceived(self, image_msg):
        if self.args['use_ir']:
            image = self.bridge.imgmsg_to_cv2(image_msg, 'mono16')
            image = image.astype(np.uint8)
        else:
            image = self.bridge.imgmsg_to_cv2(image_msg, 'bgr8')

        nx = self.config['calibration_pattern']['dimension']['x']
        ny = self.config['calibration_pattern']['dimension']['y']
        K = np.ndarray((3, 3), dtype=float, buffer=np.array(self.camera_info_msg.K))
        D = np.ndarray((5, 1), dtype=float, buffer=np.array(self.camera_info_msg.D))

        result = self.pattern.detect(image, equalize_histogram=False)

        if result['detected']:
            print('Pattern detected (' + str(len(result['ids'])) + ' out of ' + str(nx * ny) + ' corners)')
        else:
            print('Failed to detect pattern')

        self.pattern.drawKeypoints(image, result)

        if result['detected']:
            objp = np.zeros((nx * ny, 3), np.float32)
            objp[:, :2] = self.config['calibration_pattern']['size'] * np.mgrid[0:nx, 0:ny].T.reshape(-1, 2)

            # Build a numpy array with the chessboard corners
            corners = np.zeros((len(result['keypoints']), 1, 2), dtype=float)
            ids = list(range(0, len(result['keypoints'])))

            points = result['keypoints'].astype(np.int32)
            for idx, (point, id) in enumerate(zip(result['keypoints'], result['ids'])):
                corners[idx, 0, 0] = point[0][0]
                corners[idx, 0, 1] = point[0][1]
                ids[idx] = id

            # # Find pose of the camera w.r.t the chessboard
            if self.args['estimate_3d']:
                np_ids = np.array(ids, dtype=int)
                rvecs, tvecs = None, None
                _, rvecs, tvecs = cv2.aruco.estimatePoseCharucoBoard(np.array(corners, dtype=np.float32),
                                                                     np_ids, self.pattern.board,
                                                                     K, D, rvecs, tvecs)

                sensor_T_chessboard = traslationRodriguesToTransform(tvecs, rvecs)
                trans = list(sensor_T_chessboard[0: 3, 3])
                quat = list(transformations.quaternion_from_matrix(sensor_T_chessboard))

                self.broadcaster.sendTransform(trans, quat, rospy.Time.now(), 'pattern', image_msg.header.frame_id)

                # Draw frame on the image
                cv2.drawFrameAxes(image, K, D, rvecs, tvecs, 0.5)
                # https://docs.opencv.org/3.4/df/d4a/tutorial_charuco_detection.html
        if self.args['use_ir']:
            image_msg_out = self.bridge.cv2_to_imgmsg(image, 'mono8')
        else:
            image_msg_out = self.bridge.cv2_to_imgmsg(image, 'bgr8')

        self.image_pub.publish(image_msg_out)

        topic = self.config['sensors'][self.args['sensor_name']]['topic_name']
        cv2.namedWindow(topic, cv2.WINDOW_NORMAL)
        cv2.imshow(topic, image)
        key = cv2.waitKey(10)
        if key & 0xff == ord('q'):
            rospy.signal_shutdown(1)


def main():
    rospy.init_node('detect_chessboard', anonymous=True)

    parser = argparse.ArgumentParser()
    parser.add_argument("-cfg", "--config_file",
                        help='Specify if you want to configure the calibration package with a specific configuration file. If this flag is not given, the standard config.yml ill be used.',
                        type=str, required=False, default=None)
    parser.add_argument("-sn", "--sensor_name", help="Sensor to test as named in the config file.", type=str,
                        required=True)
    parser.add_argument("-e3d", "--estimate_3d", help="Sensor to test as named in the config file.",
                        action="store_true")
    parser.add_argument("-uir", "--use_ir", help="Sensor to test as named in the config file.",
                        action="store_true")
    args = vars(parser.parse_args())

    # Read config file
    config = atom_core.config_io.loadConfig(args['config_file'])

    # Create detector
    SimplePatternDetector(args, config)
    rospy.spin()


if __name__ == '__main__':
    main()
