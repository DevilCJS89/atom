#!/usr/bin/env python3
import copy
from functools import partial
import cv2
import rospy

from cv_bridge import CvBridge, CvBridgeError
from sensor_msgs.msg import Image
from geometry_msgs.msg import PointStamped

from atom_core.drawing import drawSquare2D

bridge = CvBridge()
image = None
gui_image = None
points = []


def callbackImageReceived(image_msg):
    global image

    try:  # try to convert the ROS Image message to a CV2 Image
        image = bridge.imgmsg_to_cv2(image_msg, "passthrough")
    except:
        rospy.logerr('Could not convert ros image to opencv.')


def callbackImageClickReceived(point_msg):
    rospy.loginfo('Image click received')

    point = {'x': int(point_msg.point.x), 'y': int(point_msg.point.y)}
    global points
    points.append(point)


def main():
    rospy.init_node('test_image_display_with_click', anonymous=False)

    topic_image = rospy.names.remap_name('image_topic')
    topic_image_labeled = topic_image + '/labeled'
    topic_image_click = topic_image_labeled + '/click'

    global image
    subscriber_image = rospy.Subscriber(topic_image, Image, partial(callbackImageReceived))
    subscriber_image_click = rospy.Subscriber(topic_image_click, PointStamped, callbackImageClickReceived)
    publisher_image = rospy.Publisher(topic_image_labeled, Image, queue_size=10)

    cv2.namedWindow('Image', cv2.WINDOW_AUTOSIZE)

    rate = rospy.Rate(0.1)
    while not rospy.is_shutdown():
        if image is None:
            rate.sleep()
            continue

        gui_image = copy.copy(image)

        # Draw a cross for each point
        for point in points:
            drawSquare2D(gui_image, point['x'], point['y'], size=5, color=(50,190,0))

        # Draw a line segment for each pair of consecutive points
        for point_start, point_end in zip(points[:-1], points[1:]):
            cv2.line(gui_image, pt1=(point_start['x'], point_start['y']), pt2=(point_end['x'], point_end['y']),
                     color=(0, 0, 255), thickness=1)

        image_msg = bridge.cv2_to_imgmsg(gui_image)
        publisher_image.publish(image_msg)

        # Show just for debug, not usually used
        cv2.imshow("Image", gui_image)
        cv2.waitKey(30)


if __name__ == '__main__':
    main()
